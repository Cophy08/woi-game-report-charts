<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>Team Lines</title>
	<link rel="stylesheet" type="text/css" href="team-lines.css">
	<script src="//cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
</head>
<body>
	<svg id="team-lines"></svg>
</body>
<script>

var inFile = "combos_sample2.csv";
var game = 21201;
var data = [];

/*
*
* Load csv
*
*/

d3.csv(inFile, function(d) {
	// Accessor function: Filter out data belonging to other games
	if (+d.gcode === game) {

		// Only return rows for 3 forward combinations
		if (d.p3 !== "NA" && d.p4 === "NA"
			&& d["POS.1"] !== "D" && d["POS.2"] !== "D" && d["POS.3"] !== "D"
			&& d["POS.1"] !== "G" && d["POS.2"] !== "G" && d["POS.3"] !== "G") {

			return {
				ca: +d.CA,
				cf: +d.CF,
				toi: +d.TOI,
				p1: d.p1,
				p2: d.p2,
				p3: d.p3,
				scoreDiffCat: +d["score.diff.cat"],
				strengthCat: d["strength.cat"],
				period: +d.period,
				team: d.team,
				venue: d.venue
			};
		}
	}
}, function(error, rows) {
	// Callback function
	data = rows;
	formatData();
});

/*
*
* Load csv
*
*/

var numLines = 4;
var lineHeight = 24;
var lineWidth = 130;

var numBlocks = 3;
var blockHGap = lineWidth / 2;
var blockVGap = lineHeight;

var blockHeight = 3 * lineHeight;
var blockWidth = numLines * lineWidth;

var svgWidth = numBlocks * (blockWidth + blockHGap) - blockHGap;
var svgHeight = numBlocks * (blockHeight + blockVGap) - blockVGap;

var nestedData = [];
var lineData = [];

function formatData() {

	// Nested data by period (or score situation or strengths), then nest by "home" and "away"
	// Then nest by lines, because each lines will have multiple rows of data (if we initially nested by periods, then each combination of score situation and strength will have a row)
	nestedData = [];
	nestedData = d3.nest()
		.key(function(d) { return d.period; })
		.key(function(d) { return d.venue + "&" + d.team; })
		.key(function(d) { return d.p1 + "&" + d.p2 + "&" + d.p3; })
		.entries(data);

	// Sum each line's rows
	nestedData.forEach(function(blk) {
		blk.values.forEach(function(tm) {
			tm.values.forEach(function(ln) {
				ln.cf = d3.sum(ln.values, function(d) { return d.cf; });
				ln.ca = d3.sum(ln.values, function(d) { return d.ca; });
				ln.toi = d3.sum(ln.values, function(d) { return d.toi; });
			});
		});
	});

	/*
	*
	* Figure out which lines to display for each period
	*
	*/
	lineData = [];

	// Loop through each block (period, score situation, etc.)
	nestedData.forEach(function(blk, i) {

		lineData.push([]); // block
		lineData[i].push([], []); // [away lines, home lines]

		// Loop through "home" and "away" team-lines
		blk.values.forEach(function(tm) {

			// We want data to be stored as [away, home], so get the team index
			var tmIdx = 1;
			if (tm.key.indexOf("away&") >= 0) { tmIdx = 0; }

			// Loop through the team's lines - first sort lines by toi
			var lnCount = 0;
			var includedPlayers = [];
			tm.values = tm.values.sort(function(a, b) { return b.toi - a.toi; });
			tm.values.forEach(function(ln) {

				// Split up line key into individual players
				ln.players = ln.key.split("&");

				ln.venue = tm.key.substring(0, tm.key.indexOf("&"));
				ln.team = tm.key.substring(tm.key.indexOf("&") + 1);

				// Do nothing if we already have the desired number of lines
				if (lnCount === numLines) { return; }

				if (includedPlayers.indexOf(ln.players[0]) < 0 && includedPlayers.indexOf(ln.players[1]) < 0 && includedPlayers.indexOf(ln.players[2]) < 0) {
					// Store line data
					lineData[i][tmIdx].push(ln);
					// Prevent players from included in other lines, and increment line count
					includedPlayers.push(ln.players[0], ln.players[1], ln.players[2]);
					lnCount++;
				}
			});
		});
	});

	appendPlot();
}

function appendPlot() {

	var svg = d3.select("#team-lines")
		.style("width", svgWidth + "px")
		.style("height", svgHeight + "px")
		.append("g");

	var blocks = svg.selectAll("g.block")
		.data(lineData);
	blocks.enter().append("g")
		.attr("class", function(d, i) { return "block block-" + i; })
		.attr("transform", function(d, i) { return "translate(" + (i * (blockWidth + blockHGap)) + ",0)"; });

	var teams = blocks.selectAll("g.team")
		.data(function(d) { return d; });
	teams.enter().append("g")
		.attr("class", function(d) { return "team " + d[0].venue; })
		.attr("transform", function(d, i) { return "translate(0," + (i * (blockHeight + blockVGap)) + ")"; });

	var lines = teams.selectAll("g.line")
		.data(function(d) { return d; });
	lines.enter().append("g")
		.attr("class", "line")
		.attr("transform", function(d, i) { return "translate(" + (i * lineWidth) + ",0)"; });

	var players = lines.selectAll("text.player")
		.data(function(d) {return d.players; });
	players.enter().append("text")
		.attr("class", "player")
		.attr("x", 0)
		.attr("y", function(d, i) { return i * lineHeight + lineHeight / 2; })
		.style("font-family", "sans-serif")
		.style("dominant-baseline", "middle")
		.style("fill", "#aaa")
		.text(function(d) { return d; });

	highlightChanges();
}

function highlightChanges() {



	[0, 1].forEach(function(tmIdx) {

		var players = [];
		var teamLines = [];
		lineData.forEach(function(blk, i) {
			teamLines.push([]);
			blk[tmIdx].forEach(function(ln) {
				teamLines[i].push(ln.players);
				ln.players.forEach(function(p) {
					if (players.filter(function(d) { return d.player === p; }).length <= 0) {
						players.push({ player: p });
					}
				});
			});
		});

		/*
		*
		* Record each player's line by period
		*
		*/

		players.forEach(function(p) {
			var plyrLinesByPer = [];

			// Loop through each block
			teamLines.forEach(function(blk) {

				// Loop through the lines in each block
				var isFound = false;
				blk.forEach(function(ln, i) {

					if (isFound) { return; }

					// Store position as [line 1-4, row position 1-3]
					if (ln.indexOf(p.player) >= 0) {
						isFound = true;
						plyrLinesByPer.push([i, ln.indexOf(p.player)]);
					}

				});
				if (!isFound) { plyrLinesByPer.push([-1, -1]); }
			});

			p.lines = plyrLinesByPer;
		});

		/*
		*
		* Highlight player movements
		*
		*/
		players.forEach(function(p) {
			for (var i = 1; i < p.lines.length; i++) {
				if (p.lines[i][0] !== p.lines[i - 1][0]) {
					//console.log(p.player + " changed: " + p.lines[i - 1][0] + " to " + p.lines[i][0]);

					var venue = "away";
					if (tmIdx === 1) { venue = "home"; }
					var targetG = d3.select(".block.block-" + i).select(".team." + venue);
					// targetG.append("line")
					// 	.attr("class", "movement")
					// 	.attr("x1", p.lines[i-1][0] * lineWidth + lineWidth / 2)
					// 	.attr("x2", p.lines[i][0] * lineWidth + lineWidth / 2)
					// 	.attr("y1", p.lines[i-1][1] * lineHeight + lineHeight / 2)
					// 	.attr("y2", p.lines[i][1] * lineHeight + lineHeight / 2)
					// 	.attr("stroke", function() {
					// 		if (p.lines[i-1][0] < p.lines[i][0]) { return "red"; }
					// 		else { return "blue"; }
					// 	});
					targetG.append("text")
						.attr("class", "movement")
						.attr("x", p.lines[i][0] * lineWidth - 30)
						.attr("y", p.lines[i][1] * lineHeight + lineHeight / 2)
						.style("dominant-baseline", "middle")
						.style("fill", function() {
							if (p.lines[i-1][0] < p.lines[i][0]) { return "red"; }
							else { return "blue"; }
						})
						.style("font-family", "Courier")
						.text(function() {
							var diff = Math.abs(p.lines[i][0] - p.lines[i-1][0]);
							if (p.lines[i-1][0] < p.lines[i][0]) { return "↘" + diff; }
							else { return "↗" + diff; }
						})
				}
			}
		});
		console.log(players);

	});

}
</script>
</html>