<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>Team Lines</title>
	<link rel="stylesheet" type="text/css" href="team-lines.css">
	<script src="//cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
</head>
<body>
	<svg id="team-lines"></svg>
</body>
<script>

var inFile = "combos_sample2.csv";
var game = 21201;
var data = [];
var playerDict = [];

/*
*
* Load csv
*
*/

d3.csv(inFile, function(d) {
	// Accessor function
	// Filter out data belonging to other games
	if (+d.gcode === game) {

		// Only return rows for 3F combinations and 2D combinations
		var lineType = "";
		if (d.p3 !== "NA" && d.p4 === "NA"
			&& d["POS.1"] !== "D" && d["POS.2"] !== "D" && d["POS.3"] !== "D"
			&& d["POS.1"] !== "G" && d["POS.2"] !== "G" && d["POS.3"] !== "G") {
			lineType = "f";
		} else if (d.p2 !== "NA" && d.p3 === "NA"
			&& d["POS.1"] === "D" && d["POS.2"] === "D") {
			lineType = "d";
		}

		// Store line data
		// score.diff.cat: 0 = away leading by 3+ ... 3 = tied ... 6 = home leading by 3+
		// strength.cat: relative to the home team, so 5v4 is 5 home skaters, 4 away
		if (lineType === "d" || lineType === "f") {
			var dataPt = {
				type: "d",
				ca: +d.CA,
				cf: +d.CF,
				toi: +d.TOI,
				players: [d.p1, d.p2],
				names: [d["NAME.1"], d["NAME.2"]],
				positions: [d["POS.1"], d["POS.2"]],
				scoreDiff: +d["score.diff.cat"],
				strengthDiff: d["strength.cat"],
				period: +d.period,
				team: d.team,
				venue: d.venue
			};
			// For 3F lines, append the 3rd player's data
			if (lineType === "f") {
				dataPt.type = "f";
				dataPt.players.push(d.p3);
				dataPt.names.push(d["NAME.3"]);
				dataPt.positions.push(d["POS.3"]);
			}
			return dataPt;
		}
	}
}, function(error, rows) {
	// Callback function
	// Nest data by period (or score situation or strengths)
	// Then nest by "home" and "away"
	// Then nest by line type: "f" or "d"
	// Then nest by line - each line will have multiple rows of data (one row for each combination of scoreDiff and strengthDiff)
	data = rows;
	nestedData = [];
	nestedData = d3.nest()
		.key(function(d) { return d.period; })
		.key(function(d) { return d.venue + "&" + d.team; })
		.key(function(d) { return d.type; })
		.key(function(d) { return d.players; })
		.entries(data);

	// Restore meta data to the parent data elements
	nestedData.forEach(function(period) {
		period.values.forEach(function(team) {
			team.venue = team.key.substring(0, team.key.indexOf("&"));
			team.team = team.key.substring(team.key.indexOf("&") + 1);
			team.values.forEach(function(lineType) {
				lineType.values.forEach(function(line) {
					line.players = line.key.split(",");
					line.names = line.values[0].names;
					line.positions = line.values[0].positions;
				});
			});
		});
	});

	updateData();
});

/*
*
* Load csv
*
*/

var numLines = 4;
var lineHeight = 24;
var lineWidth = 150;

var numBlocks = 3;
var blockHGap = lineWidth / 2;
var blockVGap = lineHeight;

var blockHeight = 3 * lineHeight;
var blockWidth = numLines * lineWidth;

var svgWidth = numBlocks * (blockWidth + blockHGap) - blockHGap;
var svgHeight = numBlocks * (blockHeight + blockVGap) - blockVGap;

var nestedData = [];
var lineData = [];

var scoreDiff = 4;
var strengthDiff = "all";

function updateData() {

	/*
	*
	* Aggregate data for each line based on the selected scoreDiff and strengthDiff
	*
	*/

	nestedData.forEach(function(period) {
		period.values.forEach(function(team) {
			team.values.forEach(function(lineType) {
				lineType.values.forEach(function(line) {
					// A line will contain multiple rows of data: one row for each combination of strengthDiff and scoreDiff
					// Sum only the rows that match the selected scoreDiff and strengthDiff
					var targetRows = line.values.filter(function(d) { return 1 === 1; });
					line.cf = d3.sum(targetRows, function(d) { return d.cf; });
					line.ca = d3.sum(targetRows, function(d) { return d.ca; });
					line.toi = d3.sum(targetRows, function(d) { return d.toi; });
				});
			});
		});
	});

	/*
	*
	* Flag which lines to display for each period
	*
	*/

	nestedData.forEach(function(period) {
		period.values.forEach(function(team) {
			team.values.forEach(function(lineType) {
				// Sort the lines by their total toi, then pick the top X lines, but without repeating players
				lineType.values = lineType.values.sort(function(a, b) { return b.toi - a.toi; });

				var limit = 4;
				if (lineType.key === "d") { limit = 3; }

				var includedPlayers = [];
				var lineCount = 0;

				lineType.values.forEach(function(line) {

					line.isDisplayed = false;
					if (lineCount < limit) {
						var addLine = true;
						line.players.forEach(function(p) {
							if (includedPlayers.indexOf(p) >= 0) { addLine = false; }
						})
						if (addLine) {
							line.isDisplayed = true;
							includedPlayers = includedPlayers.concat(line.players);
							lineCount++;
						}
					}
				});
			});
		});
	});

	/*
	*
	* For the displayed lines, identify player movements
	*
	*/

	nestedData.forEach(function(period, periodIdx) {

		period.values.forEach(function(team, teamIdx) {
			team.values.forEach(function(lineType, lineTypeIdx) {
				lineType.values.forEach(function(line) {

					// Get the displayed lines from the previous period (for the same team and lineType) - blank if there's no previous period
					var prevLines = [];
					if (periodIdx > 0) {
						nestedData[periodIdx - 1].values[teamIdx].values[lineTypeIdx].values;
						prevLines = prevLines.filter(function(d) { return d.isDisplayed === true; });
					}

					// Array to store each player's previous line (stored in the same order as the player ids)
					var playersPrevLines = [];

					// Get the player's line from the previous period
					line.players.forEach(function(player) {
						var prevLineFound = false;
						prevLines.forEach(function(prevLine, prevLineIdx) {
							if (!prevLineFound && prevLine.players.indexOf(player) >= 0) {
								playersPrevLines.push(prevLineIdx);
								prevLineFound = true;
							}
						});
						if (!prevLineFound) { playersPrevLines.push(-100); }
					});

					// Store the players' previous lines
					line.prevLines = playersPrevLines;
				});
			});
		});
	});

	return;

	/*
	*
	* Figure out which lines to display for each period
	*
	*/
	lineData = [];

	// Loop through each block (period, score situation, etc.)
	nestedData.forEach(function(blk, i) {

		lineData.push([]); // block
		lineData[i].push([], []); // [away lines, home lines]

		// Loop through "home" and "away" team-lines
		blk.values.forEach(function(tm) {

			// We want data to be stored as [away, home], so get the team index
			var tmIdx = 1;
			if (tm.key.indexOf("away&") >= 0) { tmIdx = 0; }

			// Loop through the team's lines - first sort lines by toi
			var lnCount = 0;
			var includedPlayers = [];
			tm.values = tm.values.sort(function(a, b) { return b.toi - a.toi; });
			tm.values.forEach(function(ln) {

				// Split up line key into individual players
				ln.players = ln.key.split("&");

				ln.venue = tm.key.substring(0, tm.key.indexOf("&"));
				ln.team = tm.key.substring(tm.key.indexOf("&") + 1);

				// Do nothing if we already have the desired number of lines
				if (lnCount === numLines) { return; }

				if (includedPlayers.indexOf(ln.players[0]) < 0 && includedPlayers.indexOf(ln.players[1]) < 0 && includedPlayers.indexOf(ln.players[2]) < 0) {
					// Store line data
					lineData[i][tmIdx].push(ln);
					// Prevent players from included in other lines, and increment line count
					includedPlayers.push(ln.players[0], ln.players[1], ln.players[2]);
					lnCount++;
				}
			});
		});
	});

	appendPlot();
}

function appendPlot() {

	var svg = d3.select("#team-lines")
		.style("width", svgWidth + "px")
		.style("height", svgHeight + "px")
		.append("g");

	var blocks = svg.selectAll("g.block")
		.data(lineData);
	blocks.enter().append("g")
		.attr("class", function(d, i) { return "block block-" + i; })
		.attr("transform", function(d, i) { return "translate(" + (i * (blockWidth + blockHGap)) + ",0)"; });

	var teams = blocks.selectAll("g.team")
		.data(function(d) { return d; });
	teams.enter().append("g")
		.attr("class", function(d) { return "team " + d[0].venue; })
		.attr("transform", function(d, i) { return "translate(0," + (i * (blockHeight + blockVGap)) + ")"; });

	var lines = teams.selectAll("g.line")
		.data(function(d) { return d; });
	lines.enter().append("g")
		.attr("class", "line")
		.attr("transform", function(d, i) { return "translate(" + (i * lineWidth) + ",0)"; });

	var players = lines.selectAll("text.player")
		.data(function(d) {return d.players; });
	players.enter().append("text")
		.attr("class", "player")
		.attr("x", 0)
		.attr("y", function(d, i) { return i * lineHeight + lineHeight / 2; })
		.style("font-family", "sans-serif")
		.style("dominant-baseline", "middle")
		.style("fill", "#aaa")
		.style("text-transform", "capitalize")
		.text(function(d) {
			var plyrProps = playerDict.filter(function(p) { return p.id === d;})[0];
			var name = plyrProps.name;
			var firstname = name.substring(0, name.indexOf(" "));
			var lastname = name.substring(name.lastIndexOf(" ") + 1);
			return lastname[0] + lastname.slice(1).toLowerCase() + ", " + firstname[0];
		});

	highlightChanges();
}

function highlightChanges() {



	[0, 1].forEach(function(tmIdx) {

		var players = [];
		var teamLines = [];
		lineData.forEach(function(blk, i) {
			teamLines.push([]);
			blk[tmIdx].forEach(function(ln) {
				teamLines[i].push(ln.players);
				ln.players.forEach(function(p) {
					if (players.filter(function(d) { return d.player === p; }).length <= 0) {
						players.push({ player: p });
					}
				});
			});
		});

		/*
		*
		* Record each player's line by period
		*
		*/

		players.forEach(function(p) {
			var plyrLinesByPer = [];

			// Loop through each block
			teamLines.forEach(function(blk) {

				// Loop through the lines in each block
				var isFound = false;
				blk.forEach(function(ln, i) {

					if (isFound) { return; }

					// Store position as [line 1-4, row position 1-3]
					if (ln.indexOf(p.player) >= 0) {
						isFound = true;
						plyrLinesByPer.push([i, ln.indexOf(p.player)]);
					}

				});
				if (!isFound) { plyrLinesByPer.push([-1, -1]); }
			});

			p.lines = plyrLinesByPer;
		});

		/*
		*
		* Highlight player movements
		*
		*/
		players.forEach(function(p) {
			for (var i = 1; i < p.lines.length; i++) {
				if (p.lines[i][0] !== p.lines[i - 1][0]) {
					//console.log(p.player + " changed: " + p.lines[i - 1][0] + " to " + p.lines[i][0]);

					var venue = "away";
					if (tmIdx === 1) { venue = "home"; }
					var targetG = d3.select(".block.block-" + i).select(".team." + venue);

					targetG.append("text")
						.attr("class", "movement")
						.attr("x", p.lines[i][0] * lineWidth - 5)
						.attr("y", p.lines[i][1] * lineHeight + lineHeight / 2)
						.style("dominant-baseline", "middle")
						.style("text-anchor", "end")
						.style("fill", function() {
							return "#222";
							if (p.lines[i-1][0] < p.lines[i][0]) { return "red"; }
							else { return "blue"; }
						})
						.style("font-family", "Courier")
						.text(function() {
							var diff = Math.abs(p.lines[i][0] - p.lines[i-1][0]);
							var flag = "↗";
							if (p.lines[i-1][0] < p.lines[i][0]) { flag = "↘"; }
							return flag + diff;
						})
				}
			}
		});
		console.log(players);

	});

}
</script>
</html>