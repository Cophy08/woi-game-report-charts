<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>Team Lines</title>
	<link rel="stylesheet" type="text/css" href="team-lines.css">
	<script src="//cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
</head>
<body>
	<svg id="team-lines"></svg>
</body>
<script>

var inFile = "combos_sample2.csv";
var game = 21201;

var data = [];
var nestedData = [];

var numDLines = 3;
var numOLines = 4;

/*
*
* Load csv
*
*/

d3.csv(inFile, function(d) {
	// Accessor function - used to filter out data belonging to other games
	if (+d.gcode === game) {

		// Only return rows for 3F combinations and 2D combinations
		var lineType = "";
		if (d.p3 !== "NA" && d.p4 === "NA"
			&& d["POS.1"] !== "D" && d["POS.2"] !== "D" && d["POS.3"] !== "D"
			&& d["POS.1"] !== "G" && d["POS.2"] !== "G" && d["POS.3"] !== "G") {
			lineType = "f";
		} else if (d.p2 !== "NA" && d.p3 === "NA"
			&& d["POS.1"] === "D" && d["POS.2"] === "D") {
			lineType = "d";
		}

		// Store line data
		if (lineType === "d" || lineType === "f") {
			var dataPt = {
				type: "d",
				ca: +d.CA,
				cf: +d.CF,
				ga: +d.GA,
				toi: +d.TOI,
				players: [d.p1, d.p2],
				names: [d["NAME.1"], d["NAME.2"]],
				positions: [d["POS.1"], d["POS.2"]],
				goals: [d["p1G"], d["p2G"]],
				scoreDiff: +d["score.diff.cat"], // 0 = away leading by 3+ ... 3 = tied ... 6 = home leading by 3+
				strengthDiff: d["strength.cat"], // Relative to the home team - e.g., 5v4 is 5 home skaters, 4 away
				period: +d.period,
				team: d.team,
				venue: d.venue
			};
			// For 3F lines, append the 3rd player's data
			if (lineType === "f") {
				dataPt.type = "f";
				dataPt.players.push(d.p3);
				dataPt.names.push(d["NAME.3"]);
				dataPt.goals.push(d["p3G"]);
				dataPt.positions.push(d["POS.3"]);
			}
			return dataPt;
		}
	}
}, function(error, rows) {
	// Callback function - used to nest data
	data = rows;
	nestedData = d3.nest()
		.key(function(d) { return d.period; }) // Nest data by period (or score situation or strengths)
		.key(function(d) { return d.venue + "&" + d.team; }) // Then nest by "home" and "away"
		.key(function(d) { return d.type; }) // Then nest by line type: "f" or "d"
		.key(function(d) { return d.players; }) // Then nest by line - each line will have multiple rows of data (one row for each combination of scoreDiff and strengthDiff)
		.entries(data);

	// Restore meta data to each level of the nested data
	nestedData.forEach(function(period) {
		period.values.forEach(function(team) {
			team.venue = team.key.substring(0, team.key.indexOf("&"));
			team.team = team.key.substring(team.key.indexOf("&") + 1);
			team.values.forEach(function(lineType) {
				lineType.values.forEach(function(line) {
					line.players = line.key.split(",");
					line.names = line.values[0].names;
					line.positions = line.values[0].positions;
				});
			});
		});
	});

	updateData();
});

/*
*
* Update data based on selected scoreDiff and strengthDiff
*
*/

function updateData() {

	/*
	*
	* Aggregate data for each line based on the selected scoreDiff and strengthDiff
	*
	*/

	nestedData.forEach(function(period) {
		period.values.forEach(function(team) {
			team.values.forEach(function(lineType) {
				lineType.values.forEach(function(line) {
					// A line will contain multiple rows of data: one row for each combination of strengthDiff and scoreDiff
					// Sum only the rows that match the selected scoreDiff and strengthDiff
					var targetRows = line.values.filter(function(d) { return 1 === 1; });
					line.cf = d3.sum(targetRows, function(d) { return d.cf; });
					line.ca = d3.sum(targetRows, function(d) { return d.ca; });
					line.toi = d3.sum(targetRows, function(d) { return d.toi; });
				});
			});
		});
	});

	/*
	*
	* Flag which lines to display for each period
	*
	*/

	nestedData.forEach(function(period) {
		period.values.forEach(function(team) {
			team.values.forEach(function(lineType) {
				// Sort the lines by their total toi, then pick the top X lines, but without repeating players
				lineType.values = lineType.values.sort(function(a, b) { return b.toi - a.toi; });

				var includedPlayers = [];
				var lineCount = 0;
				var limit = numOLines;
				if (lineType.key === "d") { limit = numDLines; }

				lineType.values.forEach(function(line) {
					line.isDisplayed = false;
					if (lineCount < limit) {
						var addLine = true;
						// Don't add the line if it's player is already included in another displayed line with higher toi
						line.players.forEach(function(p) {
							if (includedPlayers.indexOf(p) >= 0) { addLine = false; }
						})
						if (addLine) {
							line.isDisplayed = true;
							includedPlayers = includedPlayers.concat(line.players);
							lineCount++;
						}
					}
				});
			});
		});
	});

	/*
	*
	* For the displayed lines, identify each player's line in the previous period
	*
	*/

	nestedData.forEach(function(period, periodIdx) {
		period.values.forEach(function(team, teamIdx) {
			team.values.forEach(function(lineType, lineTypeIdx) {
				lineType.values.forEach(function(line) {

					// Get the displayed lines from the previous period (for the same team and lineType)
					var prevLines = [];
					if (periodIdx > 0) {
						nestedData[periodIdx - 1].values[teamIdx].values[lineTypeIdx].values;
						prevLines = prevLines.filter(function(d) { return d.isDisplayed === true; });
					}

					// Array to store each player's previous line - stored in the same order as the line's player ids
					var playersPrevLines = [];

					// For each player in the current period's line, record their line in the previous period
					line.players.forEach(function(player) {
						var prevLineFound = false;
						prevLines.forEach(function(prevLine, prevLineIdx) {
							if (!prevLineFound && prevLine.players.indexOf(player) >= 0) {
								playersPrevLines.push(prevLineIdx);
								prevLineFound = true;
							}
						});
						if (!prevLineFound) { playersPrevLines.push(-100); }
					});

					// Store the results
					line.prevLines = playersPrevLines;
				});
			});
		});
	});
}

//
//
// OLD
//
//

var numLines = 4;
var lineHeight = 24;
var lineWidth = 150;

var numBlocks = 3;
var blockHGap = lineWidth / 2;
var blockVGap = lineHeight;

var blockHeight = 3 * lineHeight;
var blockWidth = numLines * lineWidth;

var svgWidth = numBlocks * (blockWidth + blockHGap) - blockHGap;
var svgHeight = numBlocks * (blockHeight + blockVGap) - blockVGap;


var lineData = [];


var scoreDiff = 4;
var strengthDiff = "all";

function appendPlot() {

	var svg = d3.select("#team-lines")
		.style("width", svgWidth + "px")
		.style("height", svgHeight + "px")
		.append("g");

	var blocks = svg.selectAll("g.block")
		.data(lineData);
	blocks.enter().append("g")
		.attr("class", function(d, i) { return "block block-" + i; })
		.attr("transform", function(d, i) { return "translate(" + (i * (blockWidth + blockHGap)) + ",0)"; });

	var teams = blocks.selectAll("g.team")
		.data(function(d) { return d; });
	teams.enter().append("g")
		.attr("class", function(d) { return "team " + d[0].venue; })
		.attr("transform", function(d, i) { return "translate(0," + (i * (blockHeight + blockVGap)) + ")"; });

	var lines = teams.selectAll("g.line")
		.data(function(d) { return d; });
	lines.enter().append("g")
		.attr("class", "line")
		.attr("transform", function(d, i) { return "translate(" + (i * lineWidth) + ",0)"; });

	var players = lines.selectAll("text.player")
		.data(function(d) {return d.players; });
	players.enter().append("text")
		.attr("class", "player")
		.attr("x", 0)
		.attr("y", function(d, i) { return i * lineHeight + lineHeight / 2; })
		.style("font-family", "sans-serif")
		.style("dominant-baseline", "middle")
		.style("fill", "#aaa")
		.style("text-transform", "capitalize")
		.text(function(d) {
			var plyrProps = playerDict.filter(function(p) { return p.id === d;})[0];
			var name = plyrProps.name;
			var firstname = name.substring(0, name.indexOf(" "));
			var lastname = name.substring(name.lastIndexOf(" ") + 1);
			return lastname[0] + lastname.slice(1).toLowerCase() + ", " + firstname[0];
		});

	highlightChanges();
}

function highlightChanges() {



	[0, 1].forEach(function(tmIdx) {

		var players = [];
		var teamLines = [];
		lineData.forEach(function(blk, i) {
			teamLines.push([]);
			blk[tmIdx].forEach(function(ln) {
				teamLines[i].push(ln.players);
				ln.players.forEach(function(p) {
					if (players.filter(function(d) { return d.player === p; }).length <= 0) {
						players.push({ player: p });
					}
				});
			});
		});

		/*
		*
		* Record each player's line by period
		*
		*/

		players.forEach(function(p) {
			var plyrLinesByPer = [];

			// Loop through each block
			teamLines.forEach(function(blk) {

				// Loop through the lines in each block
				var isFound = false;
				blk.forEach(function(ln, i) {

					if (isFound) { return; }

					// Store position as [line 1-4, row position 1-3]
					if (ln.indexOf(p.player) >= 0) {
						isFound = true;
						plyrLinesByPer.push([i, ln.indexOf(p.player)]);
					}

				});
				if (!isFound) { plyrLinesByPer.push([-1, -1]); }
			});

			p.lines = plyrLinesByPer;
		});

		/*
		*
		* Highlight player movements
		*
		*/
		players.forEach(function(p) {
			for (var i = 1; i < p.lines.length; i++) {
				if (p.lines[i][0] !== p.lines[i - 1][0]) {
					//console.log(p.player + " changed: " + p.lines[i - 1][0] + " to " + p.lines[i][0]);

					var venue = "away";
					if (tmIdx === 1) { venue = "home"; }
					var targetG = d3.select(".block.block-" + i).select(".team." + venue);

					targetG.append("text")
						.attr("class", "movement")
						.attr("x", p.lines[i][0] * lineWidth - 5)
						.attr("y", p.lines[i][1] * lineHeight + lineHeight / 2)
						.style("dominant-baseline", "middle")
						.style("text-anchor", "end")
						.style("fill", function() {
							return "#222";
							if (p.lines[i-1][0] < p.lines[i][0]) { return "red"; }
							else { return "blue"; }
						})
						.style("font-family", "Courier")
						.text(function() {
							var diff = Math.abs(p.lines[i][0] - p.lines[i-1][0]);
							var flag = "↗";
							if (p.lines[i-1][0] < p.lines[i][0]) { flag = "↘"; }
							return flag + diff;
						})
				}
			}
		});
		console.log(players);

	});

}
</script>
</html>